use std::borrow::Borrow;

use hypercube_recursion_executor::{RecursionPublicValues, NUM_PV_ELMS_TO_HASH};
use hypercube_stark::{
    MachineConfig, MachineVerifyingKey, ShardProof, ShardVerifier, ShardVerifierError,
};
use itertools::Itertools;
use p3_baby_bear::BabyBear;
use p3_field::AbstractField;
use serde::{Deserialize, Serialize};
use slop_jagged::BabyBearPoseidon2;
use sp1_primitives::{io::SP1PublicValues, poseidon2_hash};
use strum_macros::{EnumDiscriminants, EnumTryAs};
use thiserror::Error;

use crate::RecursionAir;

pub type CompressAir<F> = RecursionAir<F, 3>;

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct PlonkBn254Proof {
    pub public_inputs: [String; 2],
    pub encoded_proof: String,
    pub raw_proof: String,
    pub plonk_vkey_hash: [u8; 32],
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct Groth16Bn254Proof {
    pub public_inputs: [String; 2],
    pub encoded_proof: String,
    pub raw_proof: String,
    pub groth16_vkey_hash: [u8; 32],
}

#[derive(Serialize, Deserialize, Clone)]
#[serde(bound(
    serialize = "C: MachineConfig, C::Challenger: Serialize",
    deserialize = "C: MachineConfig, C::Challenger: Deserialize<'de>"
))]
pub struct SP1ReduceProof<C: MachineConfig> {
    /// The compress verifying key associated with the proof.
    pub vk: MachineVerifyingKey<C>,
    /// The shard proof representing the compressed proof.
    pub proof: ShardProof<C>,
}

/// The information necessary to verify a proof for a given RISC-V program.
#[derive(Clone, Serialize, Deserialize)]
pub struct SP1VerifyingKey {
    pub vk: MachineVerifyingKey<BabyBearPoseidon2>,
}

/// A proof generated by the SP1 RISC-V zkVM.
#[derive(Clone, Serialize, Deserialize, EnumDiscriminants, EnumTryAs)]
#[strum_discriminants(derive(Default, Hash, PartialOrd, Ord))]
#[strum_discriminants(name(SP1ProofMode))]
pub enum SP1Proof {
    /// A proof generated by the core proof mode.
    ///
    /// The proof size scales linearly with the number of cycles.
    #[strum_discriminants(default)]
    Core(Vec<ShardProof<BabyBearPoseidon2>>),
    /// A proof generated by the compress proof mode.
    ///
    /// The proof size is constant, regardless of the number of cycles.
    Compressed(Box<SP1ReduceProof<BabyBearPoseidon2>>),
    /// A proof generated by the Plonk proof mode.
    Plonk(PlonkBn254Proof),
    /// A proof generated by the Groth16 proof mode.
    Groth16(Groth16Bn254Proof),
}

/// A proof generated by the SP1 RISC-V zkVM bundled together with the public values and the
/// version.
#[derive(Clone, Serialize, Deserialize)]
pub struct SP1ProofWithPublicValues {
    /// The raw proof generated by the SP1 RISC-V zkVM.
    pub proof: SP1Proof,
    /// The public values generated by the SP1 RISC-V zkVM.
    pub public_values: SP1PublicValues,
    /// The version of the SP1 RISC-V zkVM (not necessary but useful for detecting version
    /// mismatches).
    pub sp1_version: String,
    /// The integrity proof generated by the TEE server.
    pub tee_proof: Option<Vec<u8>>,
}

#[derive(Debug, Error)]
pub enum MachineVerifierError<C: MachineConfig> {
    /// An error that occurs during the verification of a shard proof.
    #[error("invalid shard proof: {0}")]
    InvalidShardProof(ShardVerifierError<C>),
    /// The public values are invalid
    #[error("invalid public values")]
    InvalidPublicValues(&'static str),
    /// There are too many shards.
    #[error("too many shards")]
    TooManyShards,
}

/// Compute the digest of the public values.
pub fn recursion_public_values_digest(
    public_values: &RecursionPublicValues<BabyBear>,
) -> [BabyBear; 8] {
    let pv_array = public_values.as_array();
    poseidon2_hash(pv_array[0..NUM_PV_ELMS_TO_HASH].to_vec())
}

/// Assert that the digest of the public values is correct.
pub fn assert_recursion_public_values_valid(public_values: &RecursionPublicValues<BabyBear>) {
    let expected_digest = recursion_public_values_digest(public_values);
    for (value, expected) in public_values.digest.iter().copied().zip_eq(expected_digest) {
        assert_eq!(value, expected);
    }
}

fn verifier() -> ShardVerifier<BabyBearPoseidon2, CompressAir<BabyBear>> {
    let compress_log_blowup = 1;
    let compress_log_stacking_height = 20;
    let compress_max_log_row_count = 20;

    let machine = CompressAir::<BabyBear>::machine_wide_with_all_chips();
    let recursion_shard_verifier = ShardVerifier::from_basefold_parameters(
        compress_log_blowup,
        compress_log_stacking_height,
        compress_max_log_row_count,
        machine.clone(),
    );

    recursion_shard_verifier
}

/// Verify a compressed proof.
pub fn verify_compressed(
    proof: &SP1ReduceProof<BabyBearPoseidon2>,
) -> Result<(), MachineVerifierError<BabyBearPoseidon2>> {
    let SP1ReduceProof { vk: compress_vk, proof } = proof;
    let verifier = verifier();
    let mut challenger = verifier.challenger();
    compress_vk.observe_into(&mut challenger);
    verifier
        .verify_shard(compress_vk, proof, &mut challenger)
        .map_err(MachineVerifierError::InvalidShardProof)?;

    // Validate public values
    let public_values: &RecursionPublicValues<_> = proof.public_values.as_slice().borrow();
    assert_recursion_public_values_valid(public_values);

    if public_values.is_complete != BabyBear::one() {
        return Err(MachineVerifierError::InvalidPublicValues("is_complete is not 1"));
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use std::fs::File;

    use super::*;

    #[test]
    fn test_verify_compress() {
        println!("current dir: {:?}", std::env::current_dir());

        let path = "proof.bin";

        let mut file = File::open(path).unwrap();

        let proof: SP1ProofWithPublicValues = bincode::deserialize_from(&mut file).unwrap();

        let proof = proof.proof;
        let proof = match proof {
            SP1Proof::Compressed(proof) => proof,
            _ => panic!("not a compressed proof"),
        };
        let result = verify_compressed(&proof);

        assert!(result.is_ok(), "Failed to verify compressed proof");
    }
}
